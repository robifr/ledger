/**
 * Copyright (c) 2024 Robi
 *
 * Ledger is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Ledger is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Ledger. If not, see <https://www.gnu.org/licenses/>.
 */

package com.robifr.ledger.data.model

import android.os.Parcelable
import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.Ignore
import androidx.room.PrimaryKey
import com.robifr.ledger.local.access.CustomerDao
import com.robifr.ledger.util.Strings
import java.math.BigDecimal
import kotlinx.parcelize.Parcelize

/**
 * @param id Product unique ID. Set to null for the value to be auto-generated by Room. See
 *   [Model.modelId] For the reason of why it's boxed type.
 * @param name Product name.
 * @param balance Product balance.
 * @param debt Customer debt is stored as a negative number, by counting
 *   [ProductOrderModel.totalPrice] from queues whose status is other than
 *   [QueueModel.Status.COMPLETED]. Use [CustomerDao.totalDebtById] to count current total debt.
 */
@Parcelize
@Entity(tableName = "customer")
data class CustomerModel(
    @get:JvmName("id") @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "id") val id: Long?,
    @get:JvmName("name") @ColumnInfo(name = "name") val name: String,
    @get:JvmName("balance") @ColumnInfo(name = "balance") val balance: Long,
    @get:JvmName("debt") @Ignore val debt: BigDecimal
) : Model, Parcelable {
  /** Reserved constructor to be used by Room upon querying. */
  constructor(id: Long, name: String, balance: Long) : this(id, name, balance, 0.toBigDecimal())

  companion object {
    @JvmStatic fun toBuilder(): NameBuild = NewBuilder()

    @JvmStatic
    fun toBuilder(customer: CustomerModel): EditBuild =
        EditBuilder()
            .setId(customer.id)
            .setName(customer.name)
            .setBalance(customer.balance)
            .setDebt(customer.debt)
  }

  @Ignore override fun modelId(): Long? = this.id

  @Ignore override fun toString(): String = Strings.classToString(this)

  /**
   * Check whether balance is sufficient before making a payment. Where current customer belongs to
   * the new queue.
   */
  @Ignore
  fun isBalanceSufficient(oldQueue: QueueModel?, newQueue: QueueModel): Boolean {
    if (this != newQueue.customer) return false

    val oldTotalPrice: BigDecimal = oldQueue?.grandTotalPrice() ?: BigDecimal.ZERO
    val originalBalance: BigDecimal =
        // Ensure customer is unchanged when they both exists.
        if (oldQueue?.customerId != null &&
            oldQueue.customerId == this.id &&
            newQueue.customerId != null &&
            newQueue.customerId == this.id)
            this.balance.toBigDecimal() + oldTotalPrice
        else this.balance.toBigDecimal()

    return (originalBalance - newQueue.grandTotalPrice()).compareTo(BigDecimal.ZERO) >= 0
  }

  /** Calculate balance when customer assigned to pay a queue. */
  @Ignore
  fun balanceOnMadePayment(queue: QueueModel): Long {
    return if (queue.status == QueueModel.Status.COMPLETED &&
        queue.paymentMethod == QueueModel.PaymentMethod.ACCOUNT_BALANCE &&
        this.balance.toBigDecimal().compareTo(queue.grandTotalPrice()) >= 0)
        (this.balance.toBigDecimal() - queue.grandTotalPrice()).toLong()
    else this.balance
  }

  /** Calculate balance when queue was changed. Where current customer belong to the new queue. */
  @Ignore
  fun balanceOnUpdatedPayment(oldQueue: QueueModel, newQueue: QueueModel): Long {
    // WARNING: If I were you, I would just stay away from this method.
    //    It's critical to ensure the balance always correctly calculated.

    val isStatusCompleted: Boolean = newQueue.status == QueueModel.Status.COMPLETED
    val isPaymentCash: Boolean = newQueue.paymentMethod == QueueModel.PaymentMethod.CASH
    val isPaymentAccountBalance: Boolean =
        newQueue.paymentMethod == QueueModel.PaymentMethod.ACCOUNT_BALANCE
    val isTotalPriceChanged: Boolean =
        oldQueue.grandTotalPrice().compareTo(newQueue.grandTotalPrice()) != 0

    val isStatusWasCompleted: Boolean = oldQueue.status == QueueModel.Status.COMPLETED
    val isPaymentWasAccountBalance: Boolean =
        oldQueue.paymentMethod == QueueModel.PaymentMethod.ACCOUNT_BALANCE

    val isOldQueueHaveCustomer = oldQueue.customerId != null && oldQueue.customer != null
    // Customer is SWITCHED when its from non-null to non-null ID only.
    // Don't accept for null to null nor null to non-null ID.
    val isCustomerSwitched: Boolean =
        this.id != null && oldQueue.customerId != null && this.id != oldQueue.customerId

    // Deduct balance.
    if (isStatusCompleted && isPaymentAccountBalance) {
      // Case when total price changed while payment method still saved as account balance.
      // We only deduct based on difference between two total prices.
      if (isTotalPriceChanged &&
          isPaymentWasAccountBalance &&
          isStatusWasCompleted &&
          isOldQueueHaveCustomer &&
          !isCustomerSwitched) {
        return (this.balance.toBigDecimal() +
                oldQueue.grandTotalPrice() - // Revert balance from old queue to obtain old balance.
                newQueue.grandTotalPrice()) // Then subtract to deduct it again with the new one.
            .toLong()

        // Case when status simply switched from uncompleted to completed
        // or when old payment is non account balance,
        // with the new queue payment method marked as account balance.
      } else if (isCustomerSwitched ||
          isTotalPriceChanged ||
          !isOldQueueHaveCustomer ||
          !isStatusWasCompleted ||
          !isPaymentWasAccountBalance) {
        return (this.balance.toBigDecimal() - newQueue.grandTotalPrice()).toLong()
      }

      // Revert balance.
    } else if (isOldQueueHaveCustomer &&
        isPaymentWasAccountBalance &&
        isStatusWasCompleted &&
        !isCustomerSwitched &&
        // Case when status changed from completed to uncompleted,
        // while payment method still saved as account balance.
        // Or when payment simply switched to cash.
        ((isPaymentAccountBalance && !isStatusCompleted) || isPaymentCash)) {
      return (this.balance.toBigDecimal() + oldQueue.grandTotalPrice()).toLong()
    }

    return this.balance
  }

  /** Calculate balance when going to revert the payment, like deleting queue. */
  @Ignore
  fun balanceOnRevertedPayment(queue: QueueModel): Long {
    return if (queue.status == QueueModel.Status.COMPLETED &&
        queue.paymentMethod == QueueModel.PaymentMethod.ACCOUNT_BALANCE)
        (this.balance.toBigDecimal() + queue.grandTotalPrice()).toLong()
    else this.balance
  }

  /** Calculate debt when customer assigned to pay a queue. */
  @Ignore
  fun debtOnMadePayment(queue: QueueModel): BigDecimal {
    return if (queue.status == QueueModel.Status.COMPLETED) this.debt
    else this.debt - queue.grandTotalPrice()
  }

  /** Calculate debt when queue was changed. Where current customer belong to the new queue. */
  @Ignore
  fun debtOnUpdatedPayment(oldQueue: QueueModel, newQueue: QueueModel): BigDecimal {
    // WARNING: Although debt will always be calculated based on total price of uncompleted queues.
    //    It does still important to calculate post-transaction debt for UI stuff.
    //    Just think twice before you do something here. You have been warned.

    val isStatusCompleted: Boolean = newQueue.status == QueueModel.Status.COMPLETED
    val isStatusWasCompleted: Boolean = oldQueue.status == QueueModel.Status.COMPLETED
    val isTotalPriceChanged: Boolean =
        oldQueue.grandTotalPrice().compareTo(newQueue.grandTotalPrice()) != 0

    // Customer is CHANGED when its from non-null to non-null or null to non-null ID.
    // Don't accept for null to null ID.
    val isCustomerChanged: Boolean = this.id != null && this.id != oldQueue.customerId

    // Revert debt when changing queue status from uncompleted to completed.
    if (isStatusCompleted && !isStatusWasCompleted && (!isCustomerChanged || isTotalPriceChanged)) {
      return this.debt + oldQueue.grandTotalPrice()

      // Add more debt when changing queue status from uncompleted to completed.
    } else if (!isStatusCompleted && (isStatusWasCompleted || isCustomerChanged)) {
      return this.debt - newQueue.grandTotalPrice()

      // Add more debt when queue total price changed by
      // calculating difference between old and new total price.
    } else if (!isStatusCompleted && isTotalPriceChanged) {
      return this.debt + oldQueue.grandTotalPrice() - newQueue.grandTotalPrice()
    }

    return this.debt
  }

  /** Calculate debt when going to revert the payment, like deleting queue. */
  @Ignore
  fun debtOnRevertedPayment(queue: QueueModel): BigDecimal {
    return if (queue.status == QueueModel.Status.COMPLETED) this.debt
    else this.debt + queue.grandTotalPrice()
  }

  interface NameBuild {
    fun setName(name: String): NewBuild
  }

  interface NewBuild {
    fun setId(id: Long?): NewBuild

    fun setBalance(balance: Long): NewBuild

    fun setDebt(debt: BigDecimal): NewBuild

    fun build(): CustomerModel
  }

  interface EditBuild : NewBuild {
    override fun setId(id: Long?): EditBuild

    override fun setBalance(balance: Long): EditBuild

    override fun setDebt(debt: BigDecimal): EditBuild

    fun setName(name: String): EditBuild
  }

  private abstract class Builder : NewBuild {
    protected lateinit var _name: String
    protected var _id: Long? = null
    protected var _balance: Long = 0L
    protected var _debt: BigDecimal = 0.toBigDecimal()

    override fun build(): CustomerModel =
        CustomerModel(this._id, this._name, this._balance, this._debt)
  }

  private class NewBuilder : Builder(), NameBuild {
    override fun setName(name: String): NewBuild = this.apply { this._name = name }

    override fun setId(id: Long?): NewBuild = this.apply { this._id = id }

    override fun setBalance(balance: Long): NewBuild = this.apply { this._balance = balance }

    override fun setDebt(debt: BigDecimal): NewBuild = this.apply { this._debt = debt }
  }

  private class EditBuilder : Builder(), EditBuild {
    override fun setName(name: String): EditBuild = this.apply { this._name = name }

    override fun setId(id: Long?): EditBuild = this.apply { this._id = id }

    override fun setBalance(balance: Long): EditBuild = this.apply { this._balance = balance }

    override fun setDebt(debt: BigDecimal): EditBuild = this.apply { this._debt = debt }
  }
}
